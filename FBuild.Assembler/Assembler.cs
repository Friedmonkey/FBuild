using FBuild.Common;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using static FBuild.Assembler.AssemblerDefinitions;

namespace FBuild.Assembler;

public partial class FriedAssembler : AnalizerBase<char>
{
    private string CurrentlyConsuming = "start"; // Tell the consumer what we are consuming so we can use it to form a detailed exception
    private string ExtraConsumingInfo = "start"; // Any other information that can be usefull to form a more specific exception
    private readonly Ilogger logger;
    public FriedAssembler(Ilogger logger) : base('\0') 
    {
        this.logger = logger;
    }
    private Dictionary<string, UInt64> Labels = new Dictionary<string, UInt64>();
    private List<Declare> Declares = new List<Declare>();
    private List<Struct> Structs = new List<Struct>();
    private int declare_size = 0;
    private List<Instruction> Instructions = new List<Instruction>();
    //private List<string> VarIdentifiers = new List<string>();
    private int autoGeneratedDeclares = 0;
    private UInt64 MaxDeclareSize = 0;
    //transform the text over time and eventually turn it into byte array
    public byte[] Parse(string input)
    {
        input = $"\n{input}\n"; //padd with newline to make parsing easier
        void UpdateAndReset()
        { //we have changed the input so we update our list
            this.Analizable = input.ToList();
            this.Position = 0; //we reset our position so we can start from the beginning again
        }

        //initial
        UpdateAndReset();

        input = ParseComments(input);
        UpdateAndReset();

        input = ParseIncludes(input);
        UpdateAndReset();

        input = ParseDeclares(input);
        UpdateAndReset();

        GetLabels(input);
        this.Position = 0;

        input = ParseInstructions(input, out UInt64 address_offset);
        UpdateAndReset();

        Declares.AddRange(Structs.Select(s => s.MakeDeclare()));
        foreach (string dec in Declares.Where(d => !d.used).Select(d => d.name))
            logger?.LogInfo($"Declare \"{dec}\" was removed because it wasnt used!");
        Declares = Declares.Where(d => d.used).OrderBy(d => d.value.Count() == 0).ToList();
        declare_size = Declares.FindIndex(d => d.value.Count() == 0); //where empty varibles start
        if (declare_size == -1) declare_size = Declares.Count();
        //basicly sorts the list like this 5,1,6,8,6,0,0,0,0 declare_size is from what point the empty starts,
        //cus we dont need to embed those because we know its value, we can count the amount of empty instead

        //replace all :labelname with labals[labalname]
        //replace all declarename with declares[declarename].index
        // by going troguh labels.keys and foreach declares (for loop cus we need index)
        input = ParseAndResolveLabelAndInstructionAddresses(input);
        UpdateAndReset();

        bool hasSymbols = true;
        if (Declares.Count() == 0)
            hasSymbols = false;
        var MetaSize = MaxDeclareSize.GetAmountOfBytesNeeded();
        input = FinalGenerator(input, address_offset, MetaSize, hasSymbols, 1);
        UpdateAndReset();

        //convert string like "20 54 6A" to actual bytes
        string[] hexValuesSplit = input.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        byte[] bytes = new byte[hexValuesSplit.Length];

        for (int i = 0; i < hexValuesSplit.Length; i++)
        {
            if (string.IsNullOrEmpty(hexValuesSplit[i]))
                continue;
            bytes[i] = Convert.ToByte(hexValuesSplit[i], 16);
        }

        //return input.ToArray();
        return bytes;
    }
    byte GetSize(Size size)
    {
        return size switch
        {
            Size.One =>     1,
            Size.Two =>     2,
            Size.Four =>    4,
            Size.Eight =>   8,
            _ => throw new NotSupportedException()
        };
    }
    private byte PackVersion(Size header, Size meta, Size emptyVar, bool includeSymbols, byte version)
    {
        // Ensure version does not exceed 1 bit
        version &= 0b00000001;

        // Pack all fields into a single byte
        byte versionByte = (byte)(
            ((byte)header << 6) |            // Header: shift 6 bits to the left
            ((byte)meta << 4) |              // Meta: shift 4 bits to the left
            ((byte)emptyVar << 2) |              // emptyVar: shift 2 bits to the left
            (includeSymbols ? 0b00000010 : 0) | // IncludeSymbols: add second bit
            (version & 0b00000001)           // Version: mask lower bit
        );

        return versionByte;
    }
    private string FinalGenerator(string instructions, UInt64 instructions_offset, Size meta, bool includeSymbols, byte version)
    {
        const string emptyVarSizeHeader = "%emptyVarSizeHeader%";
        const string instructionHeader = "%instructionHeader%";
        const string constPoolHeader = "%constPoolHeader%";
        const string symbolHeader = "%symbolHeader%";
        const string versionByteTemp = "%versionByte%";
        byte meta_size = GetSize(meta);
        UInt64 instructionHeaderPos = 0;
        UInt64 constPoolHeaderPos = 0;
        UInt64 symbolHeaderPos = 0;
        UInt64 byteCount = 0;
        StringBuilder sb = new StringBuilder();
        // Add the magic "FXE" in byte format
        sb.Append("FXE".ToByteString()); // Converts "FXE" to hex (e.g., "46 58 45")
        sb.Append(versionByteTemp);
        byteCount += 4;//magic
        sb.Append(emptyVarSizeHeader);
        byteCount += 0; //calculate later
        sb.Append(instructionHeader);
        byteCount += 0; //calculate later
        sb.Append(constPoolHeader);
        byteCount += 0; //calculate later
        if (includeSymbols)
        {
            sb.Append(symbolHeader);
            byteCount += 0; //calculate later
        }
        for (int i = 0; i < declare_size; i++) //the meta for initialized declares
        {
            Declare dec = Declares[i];
            sb.Append(((UInt64)dec.value.Count()).ToFixedByteArray(meta_size));
            byteCount += meta_size;
        }
        instructionHeaderPos = byteCount;
        sb.Append(instructions);
        byteCount += instructions_offset;
        constPoolHeaderPos = byteCount;
        foreach (Declare dec in Declares) //the the values for initialized declares
        {
            sb.Append(dec.value.ToByteString());
            byteCount += (UInt64)dec.value.Count();
        }
        if (includeSymbols)
        { 
            symbolHeaderPos = byteCount;
            foreach (Declare dec in Declares)
            { 
                sb.Append(dec.name.ToByteString());
                byteCount += (UInt64)dec.name.Count();
                sb.Append(((byte)0xBB).ToByteString()); //symbol split char, needs to be appended
                byteCount++;
            }
        }

        UInt64 emptyVarCount = (UInt64)(Declares.Count() - declare_size);
        Size emptyVar = emptyVarCount.GetAmountOfBytesNeeded();
        byte emptyVar_size = GetSize(emptyVar);

        string finalText = sb.ToString();

        //calculate the bytes needed for header size
        int numHeaders = includeSymbols ? 3 : 2;
        UInt64 largestHeader = includeSymbols ? symbolHeaderPos : constPoolHeaderPos;
        largestHeader += (UInt64)(numHeaders*8) + 8; //go off the largest

        Size bytesNeeded = largestHeader.GetAmountOfBytesNeeded();
        byte header_size = GetSize(bytesNeeded);
        byte versionByte = PackVersion(bytesNeeded, meta, emptyVar, includeSymbols, version);

        UInt64 headerOffset = (UInt64)(numHeaders * header_size) + emptyVar_size;

        instructionHeaderPos += headerOffset;
        constPoolHeaderPos += headerOffset;
        if (includeSymbols)
            symbolHeaderPos += headerOffset;

        byteCount += headerOffset;


        finalText = finalText.Replace(versionByteTemp, versionByte.ToByteString()); //replace the version byte

        finalText = finalText.Replace(emptyVarSizeHeader, emptyVarCount.ToFixedByteArray(emptyVar_size));

        finalText = finalText.Replace(instructionHeader, instructionHeaderPos.ToFixedByteArray(header_size));
        finalText = finalText.Replace(constPoolHeader, constPoolHeaderPos.ToFixedByteArray(header_size));
        if (includeSymbols) 
            finalText = finalText.Replace(symbolHeader, symbolHeaderPos.ToFixedByteArray(header_size));

        return finalText;
    }

    public List<byte> ParseBytes(out string address)
    {
        address = string.Empty;
        List<byte> bytes = new List<byte>();
        bool autoDeclare = false;
        if (Current == '@')
        { 
            autoDeclare = true;
            Consume('@');
        }
        do
        {
            SkipWhitespaceAndComments();
            if (Current == '"') //string
            {
                string str = ConsumeString();
                foreach (byte b in str) bytes.Add(b);
                address = string.Empty;
            }
            else if (Current == '\'') //char
            {
                char chr = ConsumeChar();
                bytes.Add((byte)chr);
                address = string.Empty;
            }
            else if (Current == '0' && Peek(1) is 'x' or 'X') //byte 0xFF (only parse 2 hex to make up the byte)
            {
                Consume('0');
                Position++; // Consume 'x' or 'X'

                string hexText = "";
                for (int i = 0; i < 2; i++) // Read exactly 2 characters
                {
                    char c = Peek(i);
                    if (!c.IsHexDigit()) // Validate if character is in 0-9, A-F, a-f
                        throw new FormatException($"Invalid hex character: '{c}'");

                    hexText += c;
                }
                Position += 2; // Advance the position by 2

                byte result = Convert.ToByte(hexText, 16); // Convert hex string to byte
                bytes.Add(result);
                address = string.Empty;
            }
            else if (Current == '0' && Peek(1) is 'b' or 'B') //binary 0b00001111 (only parse 8 (0 or 1) to make up the byte)
            {
                Consume('0');
                Position++; // Consume 'b' or 'B'

                string binaryText = "";
                for (int i = 0; i < 8; i++) // Read next 8 characters
                {
                    char c = Peek(i);
                    if (c != '0' && c != '1')
                        throw new FormatException($"Invalid binary character: '{c}'");

                    binaryText += c;
                }
                Position += 8; // Advance position by 8

                byte result = Convert.ToByte(binaryText, 2); // Convert binary to byte
                bytes.Add(result);
                address = string.Empty;
            }
            else if (Current is '-')
            {
                Consume('-');
                if (char.IsDigit(Current)) //signed negative number
                {
                    string numberText = "-";

                    while (char.IsDigit(Current))
                    {
                        numberText += Current;
                        Position++;
                    }

                    //convert string to integer
                    if (!int.TryParse(numberText, out int number))
                        throw new FormatException($"Invalid number format: {numberText}");

                    // make bytes
                    bytes.AddRange(number.ToByteArrayWithNegative());
                }
                else throw new Exception($"unexpected character trying to parse signed number {CurrentlyConsuming} {ExtraConsumingInfo}");
            }
            else if (char.IsDigit(Current)) //normal numbers
            {
                string numberText = "";

                while (char.IsDigit(Current))
                {
                    numberText += Current;
                    Position++;
                }

                //convert string to integer
                if (!uint.TryParse(numberText, out uint number))
                    throw new FormatException($"Invalid number format: {numberText}");

                // make bytes
                bytes.AddRange(number.ToByteArrayUnsigned());
            }
            else if (Current is '#' or '&')
            {
                char specialLookup = Current;
                Position++;
                string varName = ConsumeIdentifier();
                ExtraConsumingInfo = $"varName: {varName}";

                var declare = Declares.FirstOrDefault(d => d.name == varName);
                var struc = Structs.FirstOrDefault(s => s.name == varName);
                if (declare is null && struc is null)
                    throw new Exception($"Identifier:{varName} not found as declare or struct.");

                if (declare is not null)
                {
                    if (specialLookup is '#') //raw value, embed if possible
                    {   //if its embedded, the value is copied and therefore not included twice in final binary
                        if (declare.value.Count() == 0)
                            throw new Exception($"Cant embed uninitialized declare \"{declare.name}\"");
                        bytes.AddRange(declare.value);
                    }
                    else if (specialLookup is '&') //address of value, to have an address the declare needs to be included
                    {   // we set the address with &, so its marked as immidate
                        declare.used = true;
                        address = '&' + varName;
                    }
                }
                else if (struc is not null)
                {
                    if (specialLookup is '#') //raw value, embed if possible
                    {   //if its embedded, the value is copied and therefore not included twice in final binary
                        if (struc.fields.Count() == 0)
                            throw new Exception($"Cant embed uninitialized struct \"{struc.name}\"");
                        bytes.AddRange(struc.MakeDeclare().value);
                    }
                    else if (specialLookup is '&') //address of value, to have an address the declare needs to be included
                    {   // we set the address with &, so its marked as immidate
                        struc.used = true;
                        address = '&' + varName;
                    }
                }
            }
            else if (Current.IsVarible()) //either label/address or meta/varible/declare
            {
                string varName = ConsumeIdentifier();
                ExtraConsumingInfo = $"varName: {varName}";

                var declare = Declares.FirstOrDefault(d => d.name == varName);
                var struc = Structs.FirstOrDefault(d => d.name == varName);
                if (declare is not null)
                {
                    declare.used = true;
                    address = varName;
                }
                else if (struc is not null)
                {
                    if (Current is '.')
                    {
                        Consume('.');
                        var field = ConsumeIdentifier();
                        var idx = struc.fields.FindIndex(f => f.name == field);
                        if (idx == -1)
                            throw new Exception($"Struct {varName} does not contain field:{field}.");
                        bytes.AddRange(idx.ToByteArrayWithNegative());
                    }
                    else
                    {
                        struc.used = true;
                        address = varName;
                    }
                }
                else if (syscalls.IfContainsThenAddBytesArray(varName.ToUpper(), ref bytes))
                    continue;
                else if (math_modes.IfContainsThenAddBytesArray(varName.ToUpper(), ref bytes))
                    continue;
                else if (compare_modes.IfContainsThenAddBytesArray(varName.ToUpper(), ref bytes))
                    continue;
                else if (buffer_modes.IfContainsThenAddBytesArray(varName.ToUpper(), ref bytes))
                    continue;
                //else if (VarIdentifiers.Contains(varName))
                //{
                //    address = varName; //we cant be certain about its index just yet,
                //                       //so dont add bytes but mark as address so it can get embeded and replaced later
                //}
                else if (Labels.ContainsKey(varName))
                {
#warning should this be address or no?
                    //address = varName; //maby im not sure
                    var addr = Labels[varName];
                    if (addr == UInt64.MaxValue)
                        address = varName;
                    else
                        bytes.AddRange(((int)addr).ToByteArrayWithNegative());
                }
                else
                {
                    throw new Exception($"Identifier:{varName} not found, its not a label nor a declared varible or var, nor syscall,math_mode nor compare_mode");
                }
                if (Current is '.')
                {
                    var field = ConsumeIdentifier();
                    throw new Exception($"Unable to index into field:{field} on {varName} because {varName} was not a struct!");
                }
            }
            else
            {
                throw new Exception($"Unexpected \"{Current}\" while parsing bytes, expected either a number(1) or byte(0xFF) or binary(0b00001111) or char('H') or string(\"hello\") or address of sorts");
            }
            SkipWhitespaceAndComments();
        }
        while (Safe && IfConsume(','));

        if (autoDeclare)
        {
            if (bytes.Count() <= 4)
                logger?.LogWarning("Declaring array within 4 bytes is not needed");
            string generatedName = $"_{autoGeneratedDeclares++}";
            int index = AddDeclare(new Declare(generatedName, bytes.ToArray()) { used = true });
            bytes.Clear();
            //bytes.AddRange(index.ToByteArrayWithNegative());

            address = generatedName;
        }

        return bytes;
    }
    public void CheckName(string name)
    {
        Exception makeException(string type)
        { 
            return new Exception($"Error parsing: {CurrentlyConsuming} {name} with name \"{name}\" already exists!"); ;
        }
        if (Declares.Any(d => d.name == name)) throw makeException(nameof(Declares));
        if (Labels.ContainsKey(name)) throw makeException(nameof(Labels));
        if (Instruction_definitions.ContainsKey(name)) throw makeException(nameof(Instruction_definitions));
        if (syscalls.Contains(name)) throw makeException(nameof(syscalls));
        if (math_modes.Contains(name)) throw makeException(nameof(math_modes));
        if (compare_modes.Contains(name)) throw makeException(nameof(compare_modes));
        if (buffer_modes.Contains(name)) throw makeException(nameof(buffer_modes));
    }
    public string ParseAndResolveLabelAndInstructionAddresses(string input)
    {
        CurrentlyConsuming = "resolving addresses";

        string FinalText = input;

        //resolve labels
        var label_keys = Labels.Keys.ToArray();
        for (int i = 0; i < Labels.Count; i++)
        {
            var byte_arr = ((int)Labels[label_keys[i]]).ToByteArrayWithNegative();
            string buffer = string.Empty;
            foreach (byte bite in byte_arr)
            {
                buffer += bite.ToString("X2") + " ";
            }
            FinalText = FinalText.Replace(label_keys[i], buffer);
        }

        //resolve all varibles and declares
        
        for (int i = 0; i < Declares.Count(); i++) //this is for resolving, we do all, even empty
        {
            var index = i.ToByteArrayWithNegative(); 
            string buffer = string.Empty;
            foreach (byte bite in index)
            {
                buffer += bite.ToString("X2") + " ";
            }
            FinalText = FinalText.Replace(Declares[i].name+' ', buffer); //append space so var1 doest replace var12
        }

        return FinalText;
    }
    public string ParseInstructions(string input, out UInt64 address_offset)
    {
        address_offset = 0;
        CurrentlyConsuming = "instructions and label addresses";

        string FinalText = string.Empty;
        while (Safe)
        {
            SkipWhitespaceAndComments();
            if (!Safe) continue;
            if (Current == ':') //label addresses
            {
                Consume(':');
                string labelName = ConsumeIdentifier();
                ExtraConsumingInfo = $"labelName: {labelName}";

                if (Labels.ContainsKey(labelName))
                {
                    Labels[labelName] = address_offset; //resolve the address of the label
                }
                else
                {
                    throw new Exception("big fat error, should never happen!11!");
                }
            }
            else
            {
                string instructionName = ConsumeIdentifier();
                instructionName = instructionName.ToUpper();
                SkipWhitespaceAndComments();
                ExtraConsumingInfo = $"instructionName: {instructionName}";

                //bool autoDeclare = false;
                //if (Current == '@') //auto declare this array
                //{
                //    autoDeclare = true;
                //    Position++;
                //}

                bool isValid = Instruction_definitions.TryGetValue(instructionName, out InstructionDefinition def);
                if (!isValid)
                {
                    throw new Exception($"The instruction {instructionName} was not recognized as valid, and doest exist!");
                }
                byte arg_size = 1;
                bool isAddr = false;

                List<byte> bytes = new List<byte>();
                string arguments = string.Empty;
                for (int i = 0; i < def.paramCount; i++)
                {
                    var arg_bytes = ParseBytes(out string addr);
                    isAddr |= (!string.IsNullOrEmpty(addr));
                    if (arg_bytes.Count() > 4)
                    {
                        //maby auto generate declaration for this
                        throw new Exception($"Error {ExtraConsumingInfo} Arguments with size greather than 4 is not supported! But argument number {i} got {arg_bytes.Count()} bytes!, prefix the array with '@' to auto declare this array");
                    }
                    if (arg_bytes.Count() > arg_size)
                        arg_size = (byte)arg_bytes.Count();

#warning this may be not great
                    if (addr.StartsWith('&')) //we want address as value
                    { 
                        isAddr = false;
                        arguments += addr.Substring(1) + " "; //embed into the string to be replaced later
                    }
                    else if (string.IsNullOrEmpty(addr) || arg_bytes.Count() != 0)
                    {
                        foreach (byte bite in arg_bytes)
                        {
                            arguments += bite.ToString("X2") + " ";
                        }
                    }
                    else
                    {
                        arguments += addr + " "; //embed into the string to be replaced later
                    }
                    bytes.AddRange(arg_bytes);
                }
                //if (forceImmidiate != null)
                //{ 
                //    isAddr = (bool)forceImmidiate;
                //}

                var instruction = new Instruction(def, arg_size, !isAddr, bytes.ToArray());
                Instructions.Add(instruction);
                address_offset += 1; //the byte for the opcode
                address_offset += (UInt64)def.paramCount * (UInt64)arg_size; //the amount of parameters

                FinalText += instruction.GetByte().ToString("X2") + " ";
                FinalText += arguments;
            }
        }
        return FinalText;
    }
    public void GetLabels(string input)
    {
        CurrentlyConsuming = "labels";

        while (Safe)
        {
            if (FindStart(":"))
            {
                string labelName = ConsumeIdentifier();
                ExtraConsumingInfo = $"labelName: {labelName}";

                CheckName(labelName);
                Labels.Add(labelName , UInt64.MaxValue);
                logger?.LogDetail($"label {labelName} was added but not initialized yet");
            }
            else
            {
                Position++;
            }
        }
    }
    public string ParseDeclares(string input)
    {
        CurrentlyConsuming = "declares";

        string FinalText = string.Empty;

        while (Safe)
        {
            if (FindStart("declare_struct "))
            {
                string structDeclareName = ConsumeIdentifier();
                ExtraConsumingInfo = $"structDeclareName: {structDeclareName}";

                CheckName(structDeclareName);
                Struct struc = new Struct(structDeclareName);
                SkipWhitespaceAndComments();
                Consume('{');
                SkipWhitespaceAndComments();
                while (Safe && Find("field"))
                {
                    const string valid = "1234*";
                    SkipWhitespaceAndComments();
                    string fieldName = ConsumeIdentifier();
                    ExtraConsumingInfo = $"structDeclareName: {structDeclareName} fieldName: {fieldName}";
                    StructField field = new StructField(fieldName);
                    SkipWhitespaceAndComments();
                    Consume(':');
                    SkipWhitespaceAndComments();
                    var idx = valid.IndexOf(Current);
                    if (idx == -1)
                        throw new Exception($"Unknown value type for struct field '{Current}' {ExtraConsumingInfo}");
                    else
                    {
                        field.size = idx+1;
                        field.immidiate = true;
                        field.inital_value = new byte[field.size];
                        field.address = null;
                        if (Current is '*')
                            field.immidiate = false; //field size for pointers will get changed later
                        Position++;
                    }
                    SkipWhitespaceAndComments();
                    if (Current == '=')
                    {
                        Consume('=');
                        SkipWhitespaceAndComments();
                        List<byte> bytes = ParseBytes(out string addr);
                        if (bytes.Count != field.size)
                            throw new Exception($"Error on {CurrentlyConsuming} {ExtraConsumingInfo} bytes used for field ({bytes.Count} does not match bytes declared for field ({field.size})");
                        field.inital_value = bytes.ToArray();
                        if (!string.IsNullOrEmpty(addr))
                            field.address = addr;
                        Consume(';');
                    }
                    else if (Current == ';')
                        Consume(';');
                    else
                        throw new Exception($"unexpected char in struct declare definition, expected either '=' or ';' but got '{Current}'");
                    struc.fields.Add(field);
                    SkipWhitespaceAndComments();
                }
                Consume('}');
                Consume(';');
                Structs.Add(struc);
            }
            if (FindStart("declare "))
            {
                string declareName = ConsumeIdentifier();
                ExtraConsumingInfo = $"declareName: {declareName}";

                CheckName(declareName);
                SkipWhitespaceAndComments();

                if (Current == '=')
                {
                    Consume('=');
                    SkipWhitespaceAndComments();
                    List<byte> bytes = ParseBytes(out _);
                    Consume(';');
                    AddDeclare(new Declare(declareName, bytes.ToArray()));
                }
                else if (Current == ';')
                {
                    Consume(';');
                    AddDeclare(new Declare(declareName, new byte[0]));
                }
                else
                {
                    throw new Exception($"unexpected char in declare definition, expected either '=' or ';' but got '{Current}'");
                }

            }
            else
            {
                FinalText += Current;
                Position++;
            }
        }
        return FinalText;
    }
    private int AddDeclare(Declare declare)
    {
#warning this is terrible, if we dont use it why set it to the max size, this will need to be done later
        if ((UInt64)declare.value.Count() > MaxDeclareSize)
            MaxDeclareSize = (UInt64)declare.value.Count();

        logger?.LogDetail($"declare {declare.name} was added");
        Declares.Add(declare);
        return Declares.Count()-1;
    }
    public string ParseIncludes(string input)
    {
        CurrentlyConsuming = "includes";

        string FinalText = string.Empty;

        while (Safe)
        {
            if (FindStart("#include "))
            {
                if (Current == '"') //include other files
                {

                    Consume('"');
                    string filename = ConsumeUntil('"');
                    ExtraConsumingInfo = filename;
                    Consume('"');
                    if (File.Exists(filename))
                    {
                        logger?.LogInfo($"including file:{Path.GetFileName(filename)}");
                        string contents = File.ReadAllText(filename);
                        FinalText += contents;
                    }
                    else
                    {
                        throw new Exception($"include failed, file \"{filename}\" cannot be found.");
                    }
                }
                else if (Current == '<') //include default libraries
                {
                    throw new NotImplementedException("including default libaries is not supported yet");
                }
                else
                {
                    throw new Exception($"expected either a quote (\") or left arrow (<) for includes but got \"{Current}\" instead!");
                }
            }
            else
            {
                FinalText += Current;
                Position++;
            }
        }
        return FinalText;
    }
    public string ParseComments(string input)
    {
        CurrentlyConsuming = "comments";

        string FinalText = string.Empty;

        while (Safe)
        {
            if (FindStart("//"))
            {
                ConsumeComment();
            }
            else
            {
                FinalText += Current;
                Position++;
            }
        }
        return FinalText;
    }
    private void ConsumeComment()
    {
        var comment = ConsumeUntilEnter();
        logger?.LogDetail("Comment removed:" + comment);
        SkipWhitespace();
    }
    private string ConsumeIdentifier()
    {
        if (!Current.IsVarible())
        {
            throw new Exception($"Error trying to parse an identifier, got \'{Current}\' instead!");
        }
        string varName = string.Empty;
        while (Safe && Current.IsVarible())
        {
            varName += Current;
            Position++;
        }
        return varName;
    }
    private string ConsumeString()
    {
        Consume('"');
        string str = ConsumeUntil('"');
        Consume('"');
        return str;
    }
    private char ConsumeChar()
    {
        Consume('\'');
        char chr = Current;
        Position++;
        if (Current != '\'')
            throw new Exception($"Error while parsing a char, Expected closing ' because a char can only be a single on, got {Current} instead.");
        Consume('\'');
        return chr;
    }
    public bool FindStart(string find)
    {
        if (Find(find))
        {
            int length = find.Length + 1;
            if (Peek(-length).IsEnter())
            {
                return true;
            }
            else
            {
                Console.WriteLine($"`{find}` found, but was not at the start of a line");
                Position -= find.Length;
                return false;
            }
        }
        return false;
    }
    public string ConsumeUntilEnter()
    {
        string consumed = string.Empty;
        while (Safe && !Current.IsEnter())
        {
            consumed += Current;
            Position++;
        }
        return consumed;
    }
    public string ConsumeUntil(char stop)
    {
        string consumed = string.Empty;
        while (Safe && Current != stop)
        {
            consumed += Current;
            Position++;
        }
        return consumed;
    }
    public char Consume(char character)
    {
        if (Current == character)
        {
            Position++;
            return character;
        }
        else
            throw new Exception($"Error while parsing {CurrentlyConsuming} {ExtraConsumingInfo}, Expected `{character}` got `{Current}` instead.");
    }
    public bool IfConsume(char character)
    {
        if (Current == character)
        {
            Position++;
            return true;
        }
        else
            return false; 
    }
    public bool Find(string find)
    {
        for (int i = 0; i < find.Length; i++)
        {
            if (Peek(i) == find[i])
            {
                continue;
            }
            else return false;
        }
        Position += find.Length;
        return true;
    }
    public void SkipWhitespaceAndComments()
    {
        SkipWhitespace();
        if (Find("//"))
        {
            ConsumeComment();
            SkipWhitespaceAndComments();
        }
    }
    public void SkipWhitespace()
    {
        while (Safe && char.IsWhiteSpace(Current))
        {
            Position++;
        }
    }
}
